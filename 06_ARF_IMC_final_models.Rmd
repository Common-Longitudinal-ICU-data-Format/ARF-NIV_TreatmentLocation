---
title: "06_ARF_IMC_final_models"
author: "Sarah Goldfarb"
date: "2026-01-13"
output: html_document
---

# Load the Required Packages, specify local paths
```{r}

packages <- c(
  "tidyverse",
  "yaml",
  "rprojroot",
  "lme4",
  "broom.mixed"
)

install_if_missing <- function(pkg) {
  if (!require(pkg, character.only = TRUE)) {
    install.packages(pkg, dependencies = TRUE)
    library(pkg, character.only = TRUE)
  }
}

sapply(packages, install_if_missing)
rm(packages, install_if_missing)

# Find project root
project_root <- find_root(rprojroot::has_dir("config"))

# Read YAML config
config <- yaml::read_yaml(file.path(project_root, "config", "config.yaml"))

if(config$institution != "Hopkins"){
  stop("No need to run this file; you are done with this project!")
}

project_location <- config$project_location
outcomes   <- config$outcomes
strata_var <- config$strata_var

rm(config)

```

```{r}
# Define which sites have contributed
sites <- c("Hopkins", "Hopkins")
```

# Get file paths and clean path names
```{r}
# Output folders 
final_out_dir <- file.path(project_location, "final_federated_outputs")
dir.create(final_out_dir, recursive = TRUE, showWarnings = FALSE)

plots_out_dir <- file.path(final_out_dir, "plots")
dir.create(plots_out_dir, recursive = TRUE, showWarnings = FALSE)

models_out_dir <- file.path(final_out_dir, "models")
dir.create(models_out_dir, recursive = TRUE, showWarnings = FALSE)

data_out_dir <- file.path(final_out_dir, "stacked_data")
dir.create(data_out_dir, recursive = TRUE, showWarnings = FALSE)


# Clean outcome names the same way as in prior files
outcome_tag <- function(outcome) gsub("[^A-Za-z0-9_]+", "_", outcome)

# Identify where each site's outputs are
site_applied_dir <- function(site) {
  file.path(project_location, paste0(site, "_project_output"), "global_model_applied_outputs")
}

# Safely read CSV
safe_read_csv <- function(path) {
  if (!file.exists(path)) stop("Missing expected file: ", path)
  readr::read_csv(path, show_col_types = FALSE)
}
```

# Helper functions for calcuations and data display
```{r}
# ---------------------------
# Compute Median Odds Ratio (MOR) from random-intercept variance
# MOR = exp(0.6745 * sqrt(2 * var))
# Interpretation: median change in odds comparing identical patients at two random hospitals
# ---------------------------
compute_mor <- function(var_random_intercept) {
  if (is.na(var_random_intercept) || var_random_intercept < 0) return(NA_real_)
  exp(0.6745 * sqrt(2 * var_random_intercept))
}

# ---------------------------
# Caterpillar plot of hospital random effects (log scale)
# ---------------------------
plot_caterpillar <- function(re_df, title, out_path) {
  # re_df expected columns:
  #   hospital_uid, re_log, re_se (optional)
  p <- ggplot(re_df, aes(x = reorder(hospital_uid, re_log), y = re_log)) +
    geom_point() +
    coord_flip() +
    labs(
      title = title,
      x = "Hospital (site__hospital_id)",
      y = "Random intercept (log scale)"
    ) +
    theme_classic() +
    theme(axis.text.y = element_text(size = 6))
  ggsave(out_path, p, width = 8, height = 10)
}
```

# Model each outcome
```{r}

# Iterate over each outcome of interest
for (outcome in outcomes) {

  # Reformat outcome as has been done in prior files
  tag <- outcome_tag(outcome)

  # Collect all sites' files for this outcome
  hosp_files   <- c()  # hospital-only O/E
  strata_files <- c()  # hospital+strata O/E
  qc_files     <- c()  # QC summaries
  sites_found  <- c()  # Stores which CLIF sites have data to share

  # Iterate over each site
  for (s in sites) {

    # ----------
    # Sort through site directories and read files
    # ----------
    
    # Store site result directory
    dir_s <- site_applied_dir(s)

    # If the site folder isn't present, skip with a warning
    if (!dir.exists(dir_s)) {
      warning("Missing site applied output directory: ", dir_s, "  (site=", s, "). Skipping this site.")
      next
    }

    # Files created by locally run script
    hosp_path   <- file.path(dir_s, paste0(s, "_OE_by_hospital_", tag, ".csv"))
    strata_path <- file.path(dir_s, paste0(s, "_OE_by_hospital_and_strata_", tag, ".csv"))
    qc_path     <- file.path(dir_s, paste0(s, "_QC_expected_risk_", tag, ".csv"))

    # Require the two analytic files; QC is optional
    if (!file.exists(hosp_path) || !file.exists(strata_path)) {
      warning("Site ", s, " is missing required O/E files for outcome ", outcome, ". Skipping.")
      next
    }

    # Add this site's file paths to the list of all paths
    hosp_files   <- c(hosp_files, hosp_path)
    strata_files <- c(strata_files, strata_path)
    if (file.exists(qc_path)) qc_files <- c(qc_files, qc_path)

    # If successful to here, add this site as a contributing site
    sites_found  <- c(sites_found, s)
  }

  # If fewer than 2 CLIF sites
  if (length(sites_found) < 2) {
    stop("Need at least 2 sites to run federated outcome model for outcome ", outcome,
         ". Found: ", paste(sites_found, collapse = ", "))
  }
  
  # ----------
  # Combine sites, ensure complete data
  # ----------
  
  # Read and stack hospital-only and hospital+strata tables
  hosp_all <- purrr::map_dfr(hosp_files, safe_read_csv)
  strata_all <- purrr::map_dfr(strata_files, safe_read_csv)

  # QC stacking (for quick inspect if needed)
  qc_all <- NULL
  if (length(qc_files) > 0) {
    qc_all <- purrr::map_dfr(qc_files, safe_read_csv)
  }
  
  # Set required columns for hospital only
  required_hosp_cols <- c("site", "outcome", "first_hospital_id", "n_patients",
                          "observed_events", "expected_events")
  # Identify any missing columns
  missing_hosp_cols <- setdiff(required_hosp_cols, names(hosp_all))
  # Error if missing columns
  if (length(missing_hosp_cols) > 0) {
    stop("Hospital-only stacked dataset missing required columns: ",
         paste(missing_hosp_cols, collapse = ", "))
  }

  # Set required columns for hospital and strata
  required_strata_cols <- c(required_hosp_cols, strata_var)
  # Identify any missing columns
  missing_strata_cols <- setdiff(required_strata_cols, names(strata_all))
  # Error if missing columns
  if (length(missing_strata_cols) > 0) {
    stop("Hospital+strata stacked dataset missing required columns: ",
         paste(missing_strata_cols, collapse = ", "),
         "\nMake sure strata_var in config matches the column sites used in 05.")
  }

  # ----------
  # Ensure all data formatted correctly, expected events > 0 to avoid unstable model
  # ----------
  
  # Set globally unique hospital ID within the hospital-only and hospital+strata stacked tables
  # Also set the outcome to character data type
  hosp_all <- hosp_all |>
    mutate(
      hospital_uid = paste(site, first_hospital_id, sep = "__"),
      outcome = as.character(outcome)
    )
  
  strata_all <- strata_all |>
    mutate(
      hospital_uid = paste(site, first_hospital_id, sep = "__"),
      outcome = as.character(outcome)
    )

  # Record number of events before filtering to keep track of how many dropped
  n_before <- nrow(strata_all)
  
  # Filter out invalid rows
  strata_all <- strata_all |>
    filter(!is.na(expected_events),  # expected_events cannot be missing
           expected_events > 0, # must have expected_events > 0 to avoid unstable model
           !is.na(observed_events), # observed_events cannot be missing 
           !is.na(n_patients) # n_patients cannot be missing
          )
  
  # Record number of events after filtering to keep track of how many dropped
  n_after <- nrow(strata_all)
  
  # Output warning if any rows were dropped with filtering
  if (n_after < n_before) {
    warning("Dropped ", (n_before - n_after), " rows with expected_events <= 0 or missing in strata table for outcome ", outcome)
  }

  # ----------
  # Save stacked datasets
  # ----------
  write_csv(hosp_all, file.path(data_out_dir, paste0("stacked_OE_by_hospital_", tag, ".csv")))
  write_csv(strata_all, file.path(data_out_dir, paste0("stacked_OE_by_hospital_and_strata_", tag, ".csv")))
  if (!is.null(qc_all)) {
    write_csv(qc_all, file.path(data_out_dir, paste0("stacked_QC_", tag, ".csv")))
  }

  # ----------
  # Fit final outcome model using aggregated observed and expected data
  #     Observed events are modeled as a function of exposure data while adjusting for expected risk (the offset log(expected_events))
  #     Random intercept accounts for residual hospital-level difference not explained by covariates
  # ----------
  
  # Make sure the strata column is a factor
  strata_all[[strata_var]] <- as.factor(strata_all[[strata_var]])

  # Create a formula that references the strata_var by name, with hospital unique ID as random effect
  f <- as.formula(paste0(
    "observed_events ~ ", strata_var,
    " + offset(log(expected_events)) + (1 | hospital_uid)"
  ))

  # Fit a Poisson mixed effect model with log link  
  mod <- lme4::glmer(
    formula = f,
    data = strata_all,
    family = poisson(link = "log"),
    control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 2e5))
  )

  # ----------
  # Summarize model results in a table
  # ----------

  # Extract fixed efffects
  fe <- broom.mixed::tidy(mod, effects = "fixed", conf.int = TRUE) |>
    mutate(
      outcome = outcome,
      rr = exp(estimate),
      rr_low = exp(conf.low),
      rr_high = exp(conf.high)
    ) |>
    select(outcome, term, estimate, std.error, statistic, p.value, rr, rr_low, rr_high)

  # Random effects variance and MOR
  re_var <- as.data.frame(lme4::VarCorr(mod)) |>
    filter(grp == "hospital_uid", var1 == "(Intercept)", is.na(var2)) |>
    pull(vcov)

  mor <- compute_mor(re_var)

  model_meta <- tibble(
    outcome = outcome,
    n_rows = nrow(strata_all),
    n_hospitals = dplyr::n_distinct(strata_all$hospital_uid),
    n_sites = length(unique(strata_all$site)),
    random_intercept_variance = re_var,
    MOR = mor,
    converged = isTRUE(mod@optinfo$conv$opt == 0)
  )

  # Output model results to csvs
  write_csv(fe, file.path(models_out_dir, paste0("fixed_effects_", tag, ".csv")))
  write_csv(model_meta, file.path(models_out_dir, paste0("model_meta_", tag, ".csv")))

  # Also save the full model object 
  saveRDS(mod, file.path(models_out_dir, paste0("model_object_", tag, ".rds")))
  
  # ----------
  # Hospital random effects as a caterpillar plot  
  # ----------
  # Random intercepts on log scale; higher = worse-than-expected
  # Represent residual hospital differences after risk adjustment and strata fixed effects
  
  
  re <- lme4::ranef(mod, condVar = TRUE)$hospital_uid

  # Extract conditional variance for each hospital random effect
  # ranef(..., condVar=TRUE) stores posterior variances in an attribute
  post_var <- attr(lme4::ranef(mod, condVar = TRUE)[["hospital_uid"]], "postVar")
  # post_var is a 3D array: [1,1,hospital_index]
  re_se <- sqrt(as.numeric(post_var[1, 1, ]))

  
  re_df <- tibble(
    hospital_uid = rownames(re),
    re_log = re[, "(Intercept)"],
    re_se = re_se
  ) |>
    arrange(re_log)

  # Output the model results into a csv
  write_csv(re_df, file.path(models_out_dir, paste0("hospital_random_effects_", tag, ".csv")))

  # Plot the caterpillar plot
  plot_caterpillar(
    re_df = re_df,
    title = paste0("Hospital random effects (log scale) â€” outcome: ", outcome),
    out_path = file.path(plots_out_dir, paste0("caterpillar_hospital_RE_", tag, ".pdf"))
  )
  
  # ----------
  # Print all summaries and log
  # ----------
  cat("\n============================================================\n")
  cat("Outcome: ", outcome, "\n", sep = "")
  cat("Sites used: ", paste(sort(unique(strata_all$site)), collapse = ", "), "\n", sep = "")
  cat("Hospitals: ", dplyr::n_distinct(strata_all$hospital_uid), "\n", sep = "")
  cat("Random intercept variance: ", format(re_var, digits = 4), "\n", sep = "")
  cat("MOR: ", format(mor, digits = 4), "\n", sep = "")
  cat("Fixed effects saved to: ", file.path(models_out_dir, paste0("fixed_effects_", tag, ".csv")), "\n", sep = "")
  cat("============================================================\n")
}

cat("\nDONE: Federated compilation and modeling complete.\nOutputs are in: ", final_out_dir, "\n", sep = "")


```

